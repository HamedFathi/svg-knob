(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["svgKnob"] = factory();
	else
		root["svgKnob"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (elem) {\n    var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    // Like a real knob, it's the knob's position that determines the knob's value.\n    // Therefore, the value is computed from the knob's position (angle).\n    // However, the user has the possibility to directly set the value and in that case\n    // the knob's position (angle) will be computed from the value and the knob redrawn\n    // accordingly.\n\n    //\n    // All angles in method parameters are in [degrees] (except for polarToKnobAngle() and getViewboxCoord()).\n    //\n    // By default:\n    // - knob direction is CLOCKWISE\n    // - start position is 6 o'clock (bottom)\n    // - knob angle is:\n    //       0 [deg] angle is a   6 o'clock (bottom)\n    //      90 [deg] angle is at  9 o'clock (left)\n    //     180 [deg] angle is at 12 o'clock (top)\n    //     270 [deg] angle is at  3 o'clock (right)\n    //\n    // Trigonometric functions (sin, cos, ...) operate in polar coordinates,\n    // with 0 angle at 3 o'clock and a counter-clockwise direction.\n    // To convert from \"knob angle\" to \"polar angle\":\n    //\n    //     knob    polar\n    // --------------------\n    //        0      270\n    //       30      240\n    //       90      180\n    //      180       90\n    //      270        0\n    //      330      -60 (add 360 to get a positive equivalent value: -60 + 360 = 300)\n    //\n    // Formula: polar-angle = 270 - knob-angle\n    //\n\n    if (!elem) {\n        throw \"You must pass a DOM node reference to the Knob constructor\";\n    }\n\n    var trace = false; // when true, will log more details in the console; use enableDebug(), disableDebug() to change\n\n    // It is faster to access a property than to access a variable...\n    // See https://jsperf.com/vars-vs-props-speed-comparison/1\n\n    var NS = \"http://www.w3.org/2000/svg\";\n    var CW = true; // clock-wise\n    var CCW = !CW; // counter clock-wise\n\n    //---------------------------------------------------------------------\n    // To simplify the internal coordinates transformations, we set the view box as a 100 by 100 square.\n    // But, if a label is present, then we add 20 to the height (at the bottom) as a placeholder for the label.\n    // In summary:\n    // - 0,0..99,99: the knob itself\n    // - 0,100..99,119: the label, if any\n    var VIEWBOX_WIDTH = 100;\n    // const VIEWBOX_HEIGHT = config.with_label ? 120 : 100;\n    var HALF_WIDTH = 50; // viewBox/2\n    var HALF_HEIGHT = 50; // viewBox/2\n\n    var svg_element = void 0;\n\n    if (typeof elem === \"string\" || elem instanceof String) {\n        elem = document.querySelector(elem);\n    }\n\n    if (elem.nodeName.toLowerCase() === \"svg\") {\n        svg_element = elem;\n    } else {\n        svg_element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        elem.appendChild(svg_element);\n    }\n\n    // For the user convenience, the label can be set with the \"data-label\" attribute.\n    // If another label is set in data-config then this later definition will override data-label.\n    // let default_label = svg_element.dataset.label !== undefined ? svg_element.dataset.label : \"\";\n    var label = elem.dataset.label !== undefined ? elem.dataset.label : false;\n\n    var defaults = {\n\n        // User configurable properties. The colors are defined in the 'palettes', later on.\n\n        // No camelCase because we want to be able to have the same name in data- attributes.\n\n        label: false,\n\n        rotation: CW,\n\n        default_value: 0,\n        initial_value: 0,\n        value_min: 0.0,\n        value_max: 100.0,\n        value_resolution: 1, // null means ignore\n\n        // split knob:\n        center_zero: false,\n        center_value: null, // if null, the value will be computed from the min and max in the init() method\n        center_gap: 4, // only used when center_zero=true; is the width of the gap between the left and right track around the zero value.\n\n        // position:\n        zero_at: 270.0, // [deg] (polar) the 0 degree will be at 270 polar degrees (6 o'clock).\n        angle_min: 30.0, // [deg] Angle in knob coordinates (0 at 6 0'clock)\n        angle_max: 330.0, // [deg] Angle in knob coordinates (0 at 6 0'clock)\n\n        // background disk:\n        bg_radius: 32,\n        bg_border_width: 1,\n\n        // track background:\n        track_bg_radius: 40,\n        track_bg_width: 8,\n\n        // track:\n        track_radius: 40,\n        track_width: 8,\n\n        // cursor\n        cursor_radius: 18, // same unit as radius\n        cursor_length: 10,\n        cursor_width: 4,\n\n        // appearance:\n        palette: \"light\",\n        bg: false,\n        track_bg: true,\n        track: true,\n        cursor: false,\n        // CSS class names\n        linecap: \"butt\", // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap\n\n        // text displayed in the middle of the knob:\n        value_text: true,\n        value_position: HALF_HEIGHT + 8, // empirical value: HALF_HEIGHT + config.font_size / 3\n        font_family: \"sans-serif\",\n        font_size: 25,\n\n        // callback to get the text to display from the current value\n        display_raw: false, // if true, format callback is ignored\n        format_raw: function format_raw(v) {\n            return Math.round(v);\n        },\n        format: function format(v) {\n            return v;\n        }, // formatting of the displayed value\n        // off_text: null,                     // text to display when raw_value = min\n        // out_of_range_text: null,            // text to display when raw_value is out of range\n\n        font_weight: \"bold\",\n        markers: 0, // number of markers; 0 or false to disable\n        markers_radius: 40,\n        markers_length: 8,\n        markers_width: 2,\n\n        class_bg: \"knob-bg\",\n        class_track_bg: \"knob-track-bg\",\n        class_track: \"knob-track\",\n        class_value: \"knob-value\",\n        class_cursor: \"knob-cursor\",\n        class_markers: \"knob-markers\",\n\n        snap_to_steps: false, // TODO\n\n        // mouse wheel support:\n        mouse_wheel_acceleration: 1,\n\n        onchange: null // callback function\n    };\n\n    //---------------------------------------------------------------------\n    // Consolidate all configs:\n\n    var data_config = JSON.parse(elem.dataset.config || \"{}\");\n    var c = Object.assign({}, defaults, _palettes2.default[defaults.palette], conf, data_config);\n    // we re-assign conf and data_config for the case they override some of the palette colors.\n    var config = Object.assign(c, _palettes2.default[c.palette], conf, data_config);\n\n    //---------------------------------------------------------------------\n    // Terminates the SVG element setup:\n\n    var viewbox_height = void 0;\n    if (config.label || config.value_position >= 100 - config.font_size / 2) {\n        // make some room for the label or the value that we want to display below the knob\n        viewbox_height = 120;\n    } else {\n        viewbox_height = 100;\n    }\n\n    // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML\n    svg_element.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n    svg_element.setAttributeNS(null, \"viewBox\", \"0 0 \" + VIEWBOX_WIDTH + \" \" + viewbox_height);\n\n    // Center of arc in knob coordinates and in ViewPort\"s pixels relative to the <svg> ClientBoundingRect.\n    var arcCenterXPixels = 0;\n    var arcCenterYPixels = 0; // equal to arcCenterXPixels because the knob is a circle\n\n    //---------------------------------------------------------------------\n    // Pre-computed values to speed-up operations:\n\n    // At the top of the knob, we leave a gap between the left and right tracks.\n    // These are angles that delimit this gap:\n    var left_track_end_angle = 0; // angle in [degrees]\n    var right_track_start_angle = 0; // angle in [degrees]\n\n    //---------------------------------------------------------------------\n    // internals\n\n    var value = 0.0; // current knob's value [value_min..value_max]\n    var angle = config.angle_min; // current knob's angle in [deg] and in knob's coordinate (not polar)\n\n    var distance = 0.0; // distance from arc center to mouse position\n    var mouse_wheel_direction = 1; // dependant of the OS\n\n    //---------------------------------------------------------------------\n    // SVG elements, from back to front:\n    var svg_bg = null; // background disk:\n    var svg_track_bg = null; // track background; for non zero-centered knobs\n    var svg_track_bg_left = null; // track background; for zero-centered knobs\n    var svg_track_bg_right = null; // track background; for zero-centered knobs\n    var svg_track = null;\n    var svg_cursor = null;\n    var svg_divisions = null;\n    var svg_value_text = null;\n\n    //---------------------------------------------------------------------\n    // mouse support\n    var targetRect = void 0;\n    var minDeltaY = void 0;\n\n    //---------------------------------------------------------------------\n    // true if the current knob value is different from the default value\n    var has_changed = false; // to spare some getValue() calls when testing if value has changed from default_value\n\n    //---------------------------------------------------------------------\n    // Create the knob:\n\n    init();\n    initValue();\n    draw();\n    attachEventHandlers();\n\n    /**\n     * Having a init function allow the knob to be re-configured.\n     */\n    function init() {\n\n        if (trace) console.log(\"init()\");\n\n        if (config.center_zero) {\n            if (!config.center_value) {\n                config.center_value = getRoundedValue((config.value_max - config.value_min) / 2 + config.value_min);\n            }\n        }\n\n        // At the top of the knob, we leave a gap between the left and right tracks.\n        // 'left_track_end_angle' and 'right_track_start_angle' are the angles that delimit this gap.\n        // Only used if center_zero=true.\n        if (config.linecap === \"butt\") {\n            left_track_end_angle = polarToKnobAngle(Math.acos(-config.center_gap / 100.0) * 180.0 / Math.PI);\n            right_track_start_angle = polarToKnobAngle(Math.acos(config.center_gap / 100.0) * 180.0 / Math.PI);\n        } else {\n            left_track_end_angle = polarToKnobAngle(Math.acos(-(config.track_width * 1.3 + config.center_gap) / 100.0) * 180.0 / Math.PI);\n            right_track_start_angle = polarToKnobAngle(Math.acos((config.track_width * 1.3 + config.center_gap) / 100.0) * 180.0 / Math.PI);\n        }\n\n        // mouse_wheel_direction = _isMacOS() ? -1 : 1; //TODO: really necessary?\n    }\n\n    function initValue() {\n        // set initial value and angle:\n        setValue(config.initial_value ? config.initial_value : config.default_value);\n    }\n\n    /**\n     * Return the value \"rounded\" according to config.value_resolution\n     * @param v value\n     */\n    function getRoundedValue(v) {\n        return config.value_resolution === null ? v : Math.round(v / config.value_resolution) * config.value_resolution;\n    }\n\n    /**\n     *\n     * @param angle [deg] in knob's coordinates\n     * @returns {*}\n     */\n    function getDisplayValue(angle) {\n        if (trace) console.log(\"getDisplayValue\", config.display_raw);\n        var v = getValue(angle);\n        return config.display_raw ? config.format_raw(v) : config.format(v);\n    }\n\n    /**\n     * Trick to adjust the cursor position when the range is odd.\n     */\n    function getCursorCorrection() {\n        var isOdd = function isOdd(n) {\n            return Math.abs(n % 2) === 1;\n        };\n        return isOdd(Math.abs(config.value_max - config.value_min)) ? 0.5 : 0;\n    }\n\n    /**\n     * Get the knob's value determined by the knob's position (angle)\n     * @param a [deg] in knob's coordinates\n     * @returns {number}\n     */\n    function getValue(a) {\n        var p = a === undefined ? angle : a;\n        var v = (p - config.angle_min) / (config.angle_max - config.angle_min) * (config.value_max - config.value_min) + config.value_min;\n        return getRoundedValue(v - getCursorCorrection());\n    }\n\n    /**\n     * Set knob's value\n     * @param v\n     */\n    function setValue(v) {\n        if (v < config.value_min) {\n            value = config.value_min;\n        } else if (v > config.value_max) {\n            value = config.value_max;\n        } else {\n            value = v;\n        }\n        setAngle((v + getCursorCorrection() - config.value_min) / (config.value_max - config.value_min) * (config.angle_max - config.angle_min) + config.angle_min);\n        if (trace) console.log(\"setValue(\" + v + \") angle=\" + (v - config.value_min) / (config.value_max - config.value_min) * (config.angle_max - config.angle_min) + config.angle_min);\n        return true;\n    }\n\n    /**\n     * Set knob's angle\n     * @param new_angle in [deg]\n     * @param fire_event\n     */\n    function setAngle(new_angle, fire_event) {\n        var prev = angle;\n        var notify = fire_event && new_angle !== angle;\n        angle = Math.min(Math.max(new_angle, config.angle_min), config.angle_max);\n        if (notify) {\n            // fire the event if the change of angle affect the value:\n            if (getValue(prev) !== getValue()) {\n                notifyChange();\n            }\n        }\n    }\n\n    /**\n     * Increment (or decrement if the increment is negative) the knob's angle.\n     * @param increment\n     */\n    function incAngle(increment) {\n        setAngle(Math.min(Math.max(angle + increment, config.angle_min), config.angle_max), true);\n    }\n\n    /**\n     * Return polar coordinates angle from our \"knob coordinates\" angle\n     */\n    function knobToPolarAngle(angle) {\n        var a = config.zero_at - angle;\n        if (a < 0) a = a + 360.0;\n        if (trace) console.log(\"knobToPolarAngle \" + angle + \" -> \" + a);\n        return a;\n    }\n\n    /**\n     *\n     * @param angle [deg] with 0 at 3 o'clock\n     * @returns {number}\n     */\n    function polarToKnobAngle(angle) {\n        // \"-\" for changing CCW to CW\n        if (trace) console.log(\"polarToKnobAngle \" + angle + \" -> \" + (config.zero_at - angle + 360.0) % 360.0);\n        return (config.zero_at - angle + 360.0) % 360.0; // we add 360 to handle negative values down to -360\n    }\n\n    /**\n     * startDrag() must have been called before to init the targetRect variable.\n     */\n    function mouseUpdate(e) {\n\n        // MouseEvent.clientX (standard property: YES)\n        // The clientX read-only property of the MouseEvent interface provides\n        // the horizontal coordinate within the application's client area at which\n        // the event occurred (as opposed to the coordinates within the page).\n        // For example, clicking in the top-left corner of the client area will always\n        // result in a mouse event with a clientX value of 0, regardless of whether\n        // the page is scrolled horizontally. Originally, this property was defined\n        // as a long integer. The CSSOM View Module redefined it as a double float.\n\n        var dxPixels = e.clientX - targetRect.left;\n        var dyPixels = e.clientY - targetRect.top;\n\n        // mouse delta in cartesian coordinate with path center=0,0 and scaled (-1..0..1) relative to path:\n        // <svg> center:       (dx, dy) == ( 0,  0)\n        // <svg> top-left:     (dx, dy) == (-1,  1)\n        // <svg> bottom-right: (dx, dy) == ( 1, -1) (bottom right of the 100x100 viewBox, ignoring the bottom 100x20 for the label)\n        var dx = (dxPixels - arcCenterXPixels) / (targetRect.width / 2);\n        var dy = -(dyPixels - arcCenterYPixels) / (targetRect.width / 2); // targetRect.width car on a 20px de plus en hauteur pour le label\n\n        if (config.rotation === CCW) dx = -dx;\n\n        // convert to polar coordinates\n        var angle_rad = Math.atan2(dy, dx);\n        if (angle_rad < 0) angle_rad = 2.0 * Math.PI + angle_rad;\n\n        if (trace) console.log(\"mouseUpdate: position in svg = \" + dxPixels + \", \" + dyPixels + \" pixels; \" + dx.toFixed(3) + \", \" + dy.toFixed(3) + \" rel.; angle \" + angle_rad.toFixed(3) + \" rad\");\n\n        setAngle(polarToKnobAngle(angle_rad * 180.0 / Math.PI), true);\n\n        // distance from arc center to mouse position:\n        // distance = Math.sqrt(dx*(HALF_WIDTH/config.track_radius)*dx*(HALF_WIDTH/config.track_radius) + dy*(HALF_HEIGHT/config.track_radius)*dy*(HALF_HEIGHT/config.track_radius));\n    }\n\n    /**\n     *\n     * @param e\n     */\n    function startDrag(e) {\n\n        if (trace) console.log(\"startDrag\");\n\n        e.preventDefault();\n\n        // API: Event.currentTarget\n        //      Identifies the current target for the event, as the event traverses the DOM. It always REFERS TO THE ELEMENT\n        //      TO WHICH THE EVENT HANDLER HAS BEEN ATTACHED, as opposed to event.target which identifies the element on\n        //      which the event occurred.\n        //      https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget\n\n        // currentTarget = e.currentTarget;\n\n        // API: Element.getBoundingClientRect() (standard: YES)\n        //      The Element.getBoundingClientRect() method returns the size of an element\n        //      and its POSITION RELATIVE TO THE VIEWPORT.\n        //      The amount of scrolling that has been done of the viewport area (or any other\n        //      scrollable element) is taken into account when computing the bounding rectangle.\n        //      This means that the rectangle's boundary edges (top, left, bottom, and right)\n        //      change their values every time the scrolling position changes (because their\n        //      values are relative to the viewport and not absolute).\n        //      https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect\n\n        // targetRect = currentTarget.getBoundingClientRect(); // currentTarget must be the <svg...> object\n        targetRect = svg_element.getBoundingClientRect();\n\n        // Note: we must take the boundingClientRect of the <svg> and not the <path> because the <path> bounding rect\n        //       is not constant because it encloses the current arc.\n\n        // By design, the arc center is at equal distance from top and left.\n        arcCenterXPixels = targetRect.width / 2;\n        //noinspection JSSuspiciousNameCombination\n        arcCenterYPixels = arcCenterXPixels;\n\n        document.addEventListener(\"mousemove\", handleDrag, false);\n        document.addEventListener(\"mouseup\", endDrag, false);\n\n        mouseUpdate(e);\n        redraw();\n    }\n\n    /**\n     *\n     * @param e\n     */\n    function handleDrag(e) {\n        e.preventDefault();\n        mouseUpdate(e);\n        redraw();\n    }\n\n    /**\n     *\n     */\n    function endDrag() {\n        if (trace) console.log(\"endDrag\");\n        document.removeEventListener(\"mousemove\", handleDrag, false);\n        document.removeEventListener(\"mouseup\", endDrag, false);\n    }\n\n    /**\n     *\n     * @param e\n     * @returns {boolean}\n     */\n    function mouseWheelHandler(e) {\n\n        // WheelEvent\n        // This is the standard wheel event interface to use. Old versions of browsers implemented the two non-standard\n        // and non-cross-browser-compatible MouseWheelEvent and MouseScrollEvent interfaces. Use this interface and avoid\n        // the latter two.\n        // The WheelEvent interface represents events that occur due to the user moving a mouse wheel or similar input device.\n\n        // https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\n        // https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n\n        e.preventDefault();\n\n        var dy = e.deltaY;\n\n        if (dy !== 0) {\n            // normalize Y delta\n            if (minDeltaY > Math.abs(dy) || !minDeltaY) {\n                minDeltaY = Math.abs(dy);\n            }\n        }\n\n        incAngle(dy / minDeltaY * mouse_wheel_direction * config.mouse_wheel_acceleration);\n\n        // TODO: mouse speed detection (https://stackoverflow.com/questions/22593286/detect-measure-scroll-speed)\n\n        redraw();\n\n        return false;\n    }\n\n    /**\n     *\n     * @param e\n     */\n    function startTouch(e) {\n\n        if (trace) console.log(\"startTouch\");\n\n        e.preventDefault(); // necessary to avoid moving all the page\n\n        targetRect = svg_element.getBoundingClientRect();\n\n        // By design, the arc center is at equal distance from top and left.\n        arcCenterXPixels = targetRect.width / 2;\n        //noinspection JSSuspiciousNameCombination\n        arcCenterYPixels = arcCenterXPixels;\n\n        document.addEventListener(\"touchmove\", handleTouch, { passive: false });\n        document.addEventListener(\"touchend\", endTouch);\n    }\n\n    /**\n     *\n     * @param e\n     */\n    function handleTouch(e) {\n\n        if (trace) console.log(\"handleTouch\", e.touches);\n\n        e.preventDefault();\n\n        var touchesIndex = e.touches.length - 1;\n\n        var dxPixels = e.touches[touchesIndex].clientX - targetRect.left;\n        var dyPixels = e.touches[touchesIndex].clientY - targetRect.top;\n\n        var dx = (dxPixels - arcCenterXPixels) / (targetRect.width / 2);\n        var dy = -(dyPixels - arcCenterYPixels) / (targetRect.width / 2); // targetRect.width car on a 20px de plus en hauteur pour le label\n\n        if (config.rotation === CCW) dx = -dx;\n\n        // convert to polar coordinates\n        var angle_rad = Math.atan2(dy, dx);\n        if (angle_rad < 0) angle_rad = 2.0 * Math.PI + angle_rad;\n\n        if (trace) console.log(\"handleTouch: position in svg = \" + dxPixels + \", \" + dyPixels + \" pixels; \" + dx.toFixed(3) + \", \" + dy.toFixed(3) + \" rel.; angle \" + angle_rad.toFixed(3) + \" rad\");\n\n        setAngle(polarToKnobAngle(angle_rad * 180.0 / Math.PI), true);\n\n        redraw();\n    }\n\n    /**\n     *\n     */\n    function endTouch() {\n        if (trace) console.log(\"endTouch\");\n        document.removeEventListener(\"touchmove\", handleTouch);\n        document.removeEventListener(\"touchend\", endTouch);\n    }\n\n    /**\n     *\n     */\n    function attachEventHandlers() {\n        if (trace) console.log(\"attach attachEventHandlers\");\n        svg_element.addEventListener(\"mousedown\", function (e) {\n            startDrag(e);\n        });\n        svg_element.addEventListener(\"wheel\", function (e) {\n            mouseWheelHandler(e);\n        });\n        svg_element.addEventListener(\"touchstart\", startTouch, { passive: false });\n    }\n\n    /**\n     *\n     */\n    function notifyChange() {\n        if (trace) console.log(\"knob value has changed\");\n        var value = getValue(); // TODO: cache the value\n        var event = new CustomEvent(\"change\", { \"detail\": value });\n        //svg_element.dispatchEvent(event);\n        elem.dispatchEvent(event);\n        if (config.onchange) {\n            config.onchange(value);\n        }\n    }\n\n    /**\n     * Utility function to configure the mousewheel direction.\n     * @returns {*}\n     * @private\n     */\n    function _isMacOS() {\n        return [\"Macintosh\", \"MacIntel\", \"MacPPC\", \"Mac68K\"].indexOf(window.navigator.platform) !== -1;\n    }\n\n    /**\n     * Return viewBox X,Y coordinates\n     * @param angle in [degree] (polar, 0 at 3 o'clock)\n     * @param radius; defaults to config.radius\n     * @returns {{x: number, y: number}}\n     */\n    function getViewboxCoord(angle, radius) {\n        var a = angle * Math.PI / 180.0;\n        var r = radius === undefined ? config.track_radius : radius;\n        var x = Math.cos(a) * r;\n        var y = Math.sin(a) * r;\n        return {\n            x: config.rotation === CW ? HALF_WIDTH + x : HALF_WIDTH - x,\n            y: HALF_HEIGHT - y\n        };\n    }\n\n    /**\n     *\n     * @param from_angle in [degree] in knob's coordinates\n     * @param to_angle in [degree] in knob's coordinates\n     * @param radius\n     */\n    function getArc(from_angle, to_angle, radius) {\n\n        if (trace) console.group(\"getArc(\" + from_angle + \", \" + to_angle + \", \" + radius + \")\");\n\n        // SVG d: \"A rx,ry xAxisRotate LargeArcFlag,SweepFlag x,y\".\n        // SweepFlag is either 0 or 1, and determines if the arc should be swept in a clockwise (1), or anti-clockwise (0) direction\n        // ref: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n\n        var a0 = knobToPolarAngle(from_angle);\n        var a1 = knobToPolarAngle(to_angle);\n\n        // little trick to force a full arc (360deg) when from=0 and to=360\n        if (from_angle !== to_angle) {\n            // with this we make sure that x1 will be different than x0 within the path definition\n            a0 -= 0.0001;\n            a1 += 0.0001;\n        }\n\n        var _getViewboxCoord = getViewboxCoord(a0, radius),\n            x0 = _getViewboxCoord.x,\n            y0 = _getViewboxCoord.y;\n\n        var _getViewboxCoord2 = getViewboxCoord(a1, radius),\n            x1 = _getViewboxCoord2.x,\n            y1 = _getViewboxCoord2.y;\n\n        var delta_angle = (a0 - a1 + 360.0) % 360.0;\n\n        var large_arc = delta_angle < 180.0 ? 0 : 1;\n        var arc_direction = config.rotation === CW ? 1 : 0;\n\n        var p = \"M \" + x0 + \",\" + y0 + \" A \" + radius + \",\" + radius + \" 0 \" + large_arc + \",\" + arc_direction + \" \" + x1 + \",\" + y1;\n\n        if (trace) console.groupEnd();\n        if (trace) console.log(\"arc: \" + p);\n\n        return p;\n    }\n\n    /**\n     *\n     * @returns {*}\n     */\n    function getTrackPath() {\n\n        if (trace) console.log(\"getTrackPath()\");\n\n        var p = null;\n\n        if (config.center_zero) {\n\n            if (Array.isArray(config.center_value)) {\n                // let v = getValue();\n                // console.log('center value is an array; getValue=', getValue(), typeof v);\n                if (config.center_value.includes(getValue())) {\n                    if (trace) console.log(\"getTrackPath: center position, track not drawn\");\n                    // track is not drawn when the value is at center\n                    return p;\n                }\n            } else {\n                if (getValue() === config.center_value) {\n                    if (trace) console.log(\"getTrackPath: center position, track not drawn\");\n                    // track is not drawn when the value is at center\n                    return p;\n                }\n            }\n\n            // we assume the split is at 180 [deg] (knob\"s angle)\n            if (angle < 180) {\n                p = getArc(Math.min(angle, left_track_end_angle), left_track_end_angle, config.track_radius);\n            } else if (angle > 180) {\n                p = getArc(right_track_start_angle, Math.max(angle, right_track_start_angle), config.track_radius);\n            }\n        } else {\n            p = getArc(config.angle_min, angle, config.track_radius);\n        }\n\n        return p;\n    }\n\n    /**\n     *\n     */\n    function draw_background() {\n\n        if (trace) console.log(\"draw_background()\", config.bg);\n\n        if (!config.bg) return;\n\n        // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML\n\n        //\n        // back disk:\n        //\n        svg_bg = document.createElementNS(NS, \"circle\");\n        svg_bg.setAttributeNS(null, \"cx\", \"\" + HALF_WIDTH);\n        svg_bg.setAttributeNS(null, \"cy\", \"\" + HALF_HEIGHT);\n        svg_bg.setAttributeNS(null, \"r\", \"\" + config.bg_radius);\n        svg_bg.setAttribute(\"fill\", \"\" + config.bg_color);\n        svg_bg.setAttribute(\"stroke\", \"\" + config.bg_border_color);\n        svg_bg.setAttribute(\"stroke-width\", \"\" + config.bg_border_width);\n        svg_bg.setAttribute(\"class\", config.class_bg);\n        svg_element.appendChild(svg_bg);\n    }\n\n    /**\n     *\n     */\n    function draw_markers() {\n\n        if (trace) console.log(\"draw_markers()\", config.markers);\n\n        if (!config.markers) return;\n\n        var p = \"\";\n        var step = (config.angle_max - config.angle_min) / config.markers;\n        for (var a = config.angle_min; a <= config.angle_max; a += step) {\n            var from = getViewboxCoord(knobToPolarAngle(a), config.markers_radius); // getViewboxCoord(angle, radius)\n            var to = getViewboxCoord(knobToPolarAngle(a), config.markers_radius + config.markers_length);\n            p += \"M \" + from.x + \",\" + from.y + \" L \" + to.x + \",\" + to.y + \" \";\n        }\n\n        svg_divisions = document.createElementNS(NS, \"path\");\n        svg_divisions.setAttributeNS(null, \"d\", p);\n        svg_divisions.setAttribute(\"stroke\", \"\" + config.markers_color);\n        svg_divisions.setAttribute(\"stroke-width\", \"\" + config.markers_width);\n        svg_divisions.setAttribute(\"stroke-linecap\", config.linecap);\n        svg_divisions.setAttribute(\"class\", config.class_markers);\n        svg_element.appendChild(svg_divisions);\n    }\n\n    /*\n            function draw_units() {\n                let pos = getViewboxCoord(angle_min_polar, config.divisions_radius);    // getViewboxCoord(angle, radius)\n                svg_value_text = document.createElementNS(NS, \"text\");\n                svg_value_text.setAttributeNS(null, \"x\", `${pos.x}`);\n                svg_value_text.setAttributeNS(null, \"y\", `${pos.y}`);\n                // svg_value_text.setAttribute(\"text-anchor\", \"middle\");\n                svg_value_text.setAttribute(\"cursor\", \"default\");\n                svg_value_text.setAttribute(\"font-family\", config.font_family);\n                svg_value_text.setAttribute(\"font-size\", `10`);\n                // svg_value_text.setAttribute(\"font-weight\", `${config.font_weight}`);\n                svg_value_text.setAttribute(\"fill\", config.font_color);\n                // svg_value_text.setAttribute(\"class\", config.class_value);\n                // svg_value_text.textContent = getDisplayValue();\n                svg_value_text.textContent = config.value_min.toString();\n                svg_element.appendChild(svg_value_text);\n            }\n    */\n\n    /**\n     *\n     */\n    function draw_track_background() {\n\n        if (trace) console.log(\"draw_track_background()\", config.track_bg);\n\n        // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML\n\n        if (!config.track_bg) return;\n\n        //\n        // track background:\n        //\n        if (config.center_zero) {\n\n            // left track background\n            svg_track_bg_left = document.createElementNS(NS, \"path\");\n            svg_track_bg_left.setAttributeNS(null, \"d\", getArc(config.angle_min, left_track_end_angle, config.track_bg_radius));\n            svg_track_bg_left.setAttribute(\"stroke\", \"\" + config.track_bg_color);\n            svg_track_bg_left.setAttribute(\"stroke-width\", \"\" + config.track_bg_width);\n            svg_track_bg_left.setAttribute(\"stroke-linecap\", config.linecap);\n            svg_track_bg_left.setAttribute(\"fill\", \"transparent\");\n            svg_track_bg_left.setAttribute(\"class\", config.class_track_bg);\n            svg_element.appendChild(svg_track_bg_left);\n\n            // right track background\n            svg_track_bg_right = document.createElementNS(NS, \"path\");\n            svg_track_bg_right.setAttributeNS(null, \"d\", getArc(right_track_start_angle, config.angle_max, config.track_bg_radius));\n            svg_track_bg_right.setAttribute(\"stroke\", \"\" + config.track_bg_color);\n            svg_track_bg_right.setAttribute(\"stroke-width\", \"\" + config.track_bg_width);\n            svg_track_bg_right.setAttribute(\"stroke-linecap\", config.linecap);\n            svg_track_bg_right.setAttribute(\"fill\", \"transparent\");\n            svg_track_bg_right.setAttribute(\"class\", config.class_track_bg);\n            svg_element.appendChild(svg_track_bg_right);\n        } else {\n\n            svg_track_bg = document.createElementNS(NS, \"path\");\n            svg_track_bg.setAttributeNS(null, \"d\", getArc(config.angle_min, config.angle_max, config.track_bg_radius));\n            svg_track_bg.setAttribute(\"stroke\", \"\" + config.track_bg_color);\n            svg_track_bg.setAttribute(\"stroke-width\", \"\" + config.track_bg_width);\n            svg_track_bg.setAttribute(\"fill\", \"transparent\");\n            svg_track_bg.setAttribute(\"stroke-linecap\", config.linecap);\n            svg_track_bg.setAttribute(\"class\", config.class_track_bg);\n            svg_element.appendChild(svg_track_bg);\n        }\n    }\n\n    /**\n     *\n     */\n    function draw_track() {\n\n        if (trace) console.log(\"draw_track()\", config.track);\n\n        if (!config.track) return;\n        var p = getTrackPath();\n        if (p) {\n            svg_track = document.createElementNS(NS, \"path\");\n            svg_track.setAttributeNS(null, \"d\", p);\n            svg_track.setAttribute(\"stroke\", \"\" + config.track_color_init);\n            svg_track.setAttribute(\"stroke-width\", \"\" + config.track_width);\n            svg_track.setAttribute(\"fill\", \"transparent\");\n            svg_track.setAttribute(\"stroke-linecap\", config.linecap);\n            svg_track.setAttribute(\"class\", config.class_track);\n            svg_element.appendChild(svg_track);\n        }\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    function getTrackCursor() {\n        var a = knobToPolarAngle(angle);\n        var from = getViewboxCoord(a, config.cursor_radius);\n        var to = getViewboxCoord(a, config.cursor_radius + config.cursor_length);\n        return \"M \" + from.x + \",\" + from.y + \" L \" + to.x + \",\" + to.y;\n    }\n\n    /**\n     *\n     */\n    function draw_cursor() {\n\n        if (trace) console.log(\"draw_cursor()\", config.cursor);\n\n        if (!config.cursor) return;\n\n        var p = getTrackCursor();\n        if (p) {\n            svg_cursor = document.createElementNS(NS, \"path\");\n            svg_cursor.setAttributeNS(null, \"d\", p);\n            svg_cursor.setAttribute(\"stroke\", \"\" + config.cursor_color_init);\n            svg_cursor.setAttribute(\"stroke-width\", \"\" + config.cursor_width);\n            svg_cursor.setAttribute(\"fill\", \"transparent\");\n            svg_cursor.setAttribute(\"stroke-linecap\", config.linecap);\n            svg_cursor.setAttribute(\"class\", config.class_cursor);\n            svg_element.appendChild(svg_cursor);\n        }\n    }\n\n    /**\n     *\n     */\n    function draw_value() {\n\n        if (trace) console.log(\"draw_value\", config.value_text);\n\n        if (!config.value_text) return;\n\n        svg_value_text = document.createElementNS(NS, \"text\");\n        svg_value_text.setAttributeNS(null, \"x\", \"\" + HALF_WIDTH);\n        svg_value_text.setAttributeNS(null, \"y\", \"\" + config.value_position);\n        svg_value_text.setAttribute(\"text-anchor\", \"middle\");\n        svg_value_text.setAttribute(\"cursor\", \"default\");\n        svg_value_text.setAttribute(\"font-family\", config.font_family);\n        svg_value_text.setAttribute(\"font-size\", \"\" + config.font_size);\n        svg_value_text.setAttribute(\"font-weight\", \"\" + config.font_weight);\n        svg_value_text.setAttribute(\"fill\", config.font_color);\n        svg_value_text.setAttribute(\"class\", config.class_value);\n        svg_value_text.textContent = getDisplayValue();\n        svg_element.appendChild(svg_value_text);\n    }\n\n    /**\n     *\n     */\n    function draw() {\n\n        if (trace) console.log(\"draw()\", config);\n\n        draw_background();\n        draw_track_background();\n        draw_markers();\n        // draw_units();\n        draw_track();\n        draw_cursor();\n        draw_value();\n    }\n\n    /**\n     *\n     */\n    function redraw() {\n\n        if (trace) console.log(\"redraw()\", config);\n\n        var p = getTrackPath();\n        if (p) {\n            if (svg_track) {\n                if (trace) console.log(\"redraw track already exist, update d\");\n                svg_track.setAttributeNS(null, \"d\", p);\n            } else {\n                if (trace) console.log(\"redraw draw_track\");\n                draw_track();\n            }\n        } else {\n            if (svg_track) {\n                if (trace) console.log(\"redraw track already exist, hide it\");\n                svg_track.setAttributeNS(null, \"d\", \"\"); // we hide the track\n            }\n        }\n\n        if (!has_changed) {\n            has_changed = getValue() !== config.default_value;\n            if (has_changed) {\n                if (svg_track) {\n                    svg_track.setAttribute(\"stroke\", \"\" + config.track_color);\n                }\n            }\n        }\n\n        if (svg_cursor) {\n            p = getTrackCursor();\n            if (p) {\n                console.log(\"redraw cursor\");\n                svg_cursor.setAttributeNS(null, \"d\", p);\n                if (has_changed) {\n                    svg_cursor.setAttribute(\"stroke\", \"\" + config.cursor_color);\n                }\n            }\n        }\n\n        if (svg_value_text) {\n            if (trace) console.log(\"redraw svg_value_text\");\n            svg_value_text.textContent = getDisplayValue();\n        }\n    }\n\n    /**\n     *\n     */\n    return {\n        set value(v) {\n            // console.group(\"value setter\");\n            setValue(v);\n            redraw();\n            // console.groupEnd();\n        },\n        set config(new_config) {\n            // console.group(\"config setter\");\n            config = Object.assign({}, defaults, config, new_config);\n            init();\n            redraw();\n            // console.groupEnd();\n        },\n        setConfigValue: function setConfigValue(attribute, value) {\n            // console.group(\"setConfigValue\");\n            config[attribute] = value;\n            init();\n            redraw();\n            // console.groupEnd();\n        },\n        initValue: initValue,\n        enableDebug: function enableDebug() {\n            trace = true;\n        },\n        disableDebug: function disableDebug() {\n            trace = false;\n        }\n    };\n};\n\nvar _palettes = __webpack_require__(/*! ./palettes.js */ \"./src/palettes.js\");\n\nvar _palettes2 = _interopRequireDefault(_palettes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://svgKnob/./src/index.js?");

/***/ }),

/***/ "./src/palettes.js":
/*!*************************!*\
  !*** ./src/palettes.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//TODO: make _init attributes optional\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    light: {\n        bg_color: \"#E0E0E0\",\n        bg_border_color: \"#BDBDBD\",\n        track_bg_color: \"#CFD8DC\",\n        track_color_init: \"#64B5F6\",\n        track_color: \"#42A5F5\",\n        cursor_color_init: \"#64B5F6\",\n        cursor_color: \"#42A5F5\",\n        markers_color: \"#9E9E9E\",\n        font_color: \"#424242\"\n    },\n    light2: {\n        bg_color: \"#B1DAEE\",\n        bg_border_color: \"#569DC0\",\n        track_bg_color: \"#B1DAEE\",\n        track_color_init: \"#569DC0\",\n        track_color: \"#1D6D93\",\n        cursor_color_init: \"#569DC0\",\n        cursor_color: \"#1D6D93\",\n        markers_color: \"#3680A4\",\n        font_color: \"#1D6D93\"\n    },\n    dark: {\n        bg_color: \"#000000\",\n        bg_border_color: \"#569DC0\",\n        track_bg_color: \"#424242\",\n        track_color_init: \"#FDD835\",\n        track_color: \"#FFEC00\",\n        cursor_color_init: \"#569DC0\",\n        cursor_color: \"#FDD835\",\n        markers_color: \"#3680A4\",\n        font_color: \"#FFEA00\"\n    }\n};\n\n//# sourceURL=webpack://svgKnob/./src/palettes.js?");

/***/ })

/******/ });
});